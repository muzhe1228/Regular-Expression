# Regular-Expression

## 正则表达式

#### 1.量词元字符

```javascript
* 零到多次
+ 一到多次
? 零次或者一次
{n} 出现n次
{n,} 出现n到多次
{n,m} 出现n到m次
```



#### 2.特殊元字符：单个或者组合在一起代表特殊的含义

```javascript
\ 转义字符 (普通=>特殊=>普通)

. 除了\n(换行符)以外的任意字符

^ 以哪一个元字符作为开始

$ 以哪一个元字符作为结束

\n 换行符

\d 0~9 之间的一个数字

\D 非0~9之间的一个数字 (大写的意思是相反的)

\w 数字、字母、下划线中的任意一个字符

\s 一个空白字符 (包括空格、制表符、换页符等)

\t 一个制表符 (一个 TAB 键 四个空格)

\b 匹配一个单词的边界

x|y x或者y中的一个字符

[xyz] x或者y或者z中的任意一个字符

[^xy] 除去 x/y 以外的任意字符

[a-z] 指 a-z 这个范围内的任意字符 [0-9a-zA-Z] === \w

[^a-z] 上一个的取反

() 正则中的分组符号

(?:) 只匹配不捕获

(?=) 正向预查
 
(?!) 负向预查

```



#### 3.普通元字符：代表本身含义

```javascript
/webken/ 正则匹配的就是  webken
```



#### 4.修饰符  "img"

```javascript
i => ignoreCase  忽略单词大小写匹配

m => multiline  可以进行多行匹配

g => global  全局匹配
```



### 常用正则表达式

------

#### 1.验证是否是有效数字

```javascript
/*
 * 规则分析
 * 1.可能出现 + - 号，也可能不出现  [+-]?
 * 2.一位0-9都可，多位首位不能是0  (\d|([1-9]\d+))
 * 3.小数部分可能没有，一旦有后面必须有小数点+数字  (\.\d+)?
 */

let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
```

#### 2.验证密码

```javascript
//=>数字、字母、下划线  /w
//=> 6~16位  {6,16}

let pwd="password_123",
    reg = /^/w{6,16}$/;
reg.test(pwd)
```

#### 3.验证真实姓名

```javascript
/*
 * 1.汉字  /^[\U4E00-\U9FA5]/  (全部汉字)
 * 2.名字长度 2~10位  [\U4E00-\u9FA5]{2,10}
 * 3.可能有译名·汉字  (·[\U4E00-\u9FA5]{2,10}){0,}
 */
let reg = /^[\U4E00-\u9FA5]{2,10}(·[\U4E00-\u9FA5]{2,10}){0,}$/;

"尼古拉斯·赵四"

```

#### 4.验证邮箱的 => 分析

```javascript
let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-|\+)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
/*
 * => w+((-\w+)|(\.\w+))*
 * 1.开头是数字字母下划线(1到多位)
 * 2.还可以是 - 数字、字母、下划线  或者  . 数字、字母、下划线，整体零到多次
 * ** 邮箱的名字由“数字、字母、下划线、-、.”几部分组成，但是-/.不能连续出现也不能为开始
 
 * => @[a-zA-Z0-9]+
 * 1.@后面紧跟着：数组、字母、下划线(1-多位)
 
 * => ((\.|-)[A-Za-z0-9]+)*
 * 1.对@后面名字的补充
 * 多域名 .com.cn
 * 企业邮箱 @webken-web-study.com
 
 * => \.[A-Za-z0-9]+
 * 1. @xxx.com / @xxx.cn 这个是匹配的最后的域名  (.com/.cn/.org/.edu/.net/.vip...)
 */
```

#### 5.身份证号码

```javascript
/*
 * 1.一共18位
 * 2.最后一位可能是 X
 *
 * 身份证前六位：省市县 411421
 * 中间8位：是年月日
 * 最后四位
 *   最后一位 => X或者数字
 *   倒数第二位 => 偶数 女  奇数 男
 *   其余的是经过算法算出来的
 */

 //let reg = /^\d{17}(\d|X)$/;
//=> 小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容
  var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/
  reg.exec('411421199512107218') //=>["411421199512107218", "411421", "1995", "12", "10", "1", "8"]  捕获结果是数组，包含每一个小分组单独获取的内容

```

